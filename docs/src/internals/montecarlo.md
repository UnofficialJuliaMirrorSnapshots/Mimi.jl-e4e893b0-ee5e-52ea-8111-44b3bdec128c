# Sensitivity Analysis support

## Overview

Sensitivity Analysis support consists of four primary user-facing elements:

1. The `@defsim` macro, which defines random variables (RVs) which are assigned distributions and associated with model parameters, and override the default (random) sampling method.

2. The `generate_trials!` function, which generates all trial data and save all random variable values in a file.

3. The `set_models!` function, which sets the model(s) on which a simulation can be run.

4. The `run_sim` function, which runs a simulation, with optional parameters describing the number of trials and models to run, and optional callback functions to customize simulation behavior.

These are described further below.

## The @defsim macro

Sensitivity Analysis Simulations are defined using the macro `@defsim`, which does the following:

* Defines random variables (RV) by assigning names to distributions, which can be any object that supports the following function:
  
    `rand(dist, count::Int=1)`

  which produces a single value when `count == 1`, else a `Vector` of values.
  
  If using Latin Hypercube Sampling (LHS) is used, the following function must also be defined:

  `quantile(dist, quantiles::Vector{Float64})`
  
  which returns values for the given `quantiles` of the distribution.

  In addition to the distributions available in the `Distributions` package, Mimi provides:

  * `EmpiricalDistribution`, which takes a vector of values and (optional) vector of probabilities and produces samples from these values using the given probabilities, if provided, or equal probability otherwise.

  * `SampleStore{T}`, which stores a vector of samples that are produced in order by the `rand` function. This allows the user to to store a predefined set of values (useful for regression testing) and it is used by the LHS method, which draws all required samples at once at equal probability intervals and then shuffles the values. It is also used when rank correlations are specified, since this requires re-ordering draws from random variables.

  * `ReshapedDistribution`, which supports use of vector-valued distributions, i.e., those that generate   vectors of values for each single draw. An example (that motivated this addition) is the `Dirichlet` distribution, which produces a vector of values that sum to 1. To use this in `@defsim`, you might do:
    ```julia
      rd = ReshapedDistribution([5, 5], Dirichlet(25,1))
    ```
    This code creates a pseudo-distribution that, for each draw, produces a 5x5 matrix of values that sum to 1.

* Defines how to apply the values generated by each RV to model parameters based on a pseudo-assignment operator:
  * `param = RV` replaces the values in the parameter with the value of the RV for the current trial.
  * `param += RV` replaces the values in the parameter with the sum of the original value and the value of the RV for the current trial.
  * `param *= RV` replaces the values in the parameter with the product of the original value and the value of the RV for the current trial.

* Defines desired rank correlations between pairs of random variables. Approximate rank correlation is achieved by re-ordering vectors of random draws as per Iman and Conover (1982).

The `@defsim` macro returns a `Simulation{T}` instance, which contains all the definition information in a form that can be applied at run-time. The `T` in `Simulation{T}` is any type that your application would like to live inside the `Simulation` struct. We have implemented three types for `T <: AbstractSimulationData`:
1. Simple random-sampling Monte Carlo Simulation (`MCSData`),
2. Latin Hypercube Sampling (`LHSData`), and
3. Sobol sampling and analysis (`SobolData`)

We also define type constants with friendlier names for these parameterized types:

```julia
const MonteCarloSimulation = Simulation{MCSData}

const LatinHypercubeSimulation = Simulation{LHSData}

const SobolSimulation = Simulation{SobolData}
```

Latin Hypercube sampling divides the distribution into equally-spaced quantiles, obtains values at those quantiles, and then shuffles the values. The result is better representation of the tails of the distribution with fewer samples than would be required for purely random sampling. Note that in the current implementation, rank correlation between parameters is supported only for `LatinHypercubeSimulation`.


## The generate_trials! function

The `generate_trials!` function is used to pre-generate data using the given `samplesize` and save all random variable values in the file `filename`. Its calling signature is:

```julia
  generate_trials!(sim::Simulation, samplesize::Int; filename::Union{String, Nothing}=nothing)
```

If the `sim` parameter has multiple scenarios and the `scenario_loop` placement is set to `OUTER`, this function must be called if the user wants to ensure the same trial data be used in each scenario. If this function is not called, new trial data will be generated for each scenario. 

Also note that if the `filename` argument is used, all random variable draws are saved to the given filename. Internally, any `Distribution` instance is converted to a `SampleStore` and the values are subsequently returned in the order generated when `rand!` is called.

## Assigning distributions

In `@defsim`, you can apply distributions to specific slices of array parameters,
and you can "bulk assign" distributions to elements of a vector or matrix
using a more condensed syntax.

### Assigning to array slices

Options for applying distributions to array slices is accomplished using
array access syntax on the left-hand side of an assignment. The assignment
may use any of these assignment operators: `=`, `*=`, or `+=`, as described
above. Slices can be indicated using a variety of specifications. Assume we
define two parameters in `@defcomp` as
```
  foo = Parameter(index=[regions])
  bar = Parameter(index=[time, regions])
```
with `regions` defined as `[:USA, :CAN, :MEX, :ROW]`

We can assign distributions to the elements of `foo` several ways:

* Using a symbol or string or tuple of symbols or strings. Note that values specified without a ":" prefix or double quotes are treated as symbols. To specify strings, quote them the usual way.
  * `foo[USA] = Uniform(0, 1)` would assign the RV to `foo[:USA]` only.
  * `foo[(USA, CAN, MEX)] = Uniform(0, 1)` would assign the same RV to 3 elements of `foo`. 
    That is, a single value is drawn from the RV with distribution `Uniform(0, 1)` and this
    value is assigned to all three elements of `foo`.
* A `:`, indicating all elements for this dimension
  * `foo[:] = Normal(10.0 3.0)` would use a draw from the Normal RV for all elements of `foo`.
* A `:` range, with or without a step, or a tuple of integers
  * `bar[2050:10:2080, :] = Uniform(2, 3)` would assign a single Uniform RV to all regions for 
    time steps with labels 2050, 2060, 2070, and 2080.
  * `bar[(2050, 2060, 2070, 2080), :] = Uniform(2, 3)` does the same thing using a tuple of values.

If `regions` were defined using strings, as in `["USA", "CAN", "MEX", "ROW"]`, the examples above would be
written as `foo["USA"] = Uniform(0, 1)` and so on.

### Assigning a vector of distributions

In some cases, it's more convenient to assign a vector of distributions (e.g., with different functional forms or parameters) to a single parameter. For example we can use the following syntax:

```julia
  foo = [USA => Uniform(0, 1),
         (CAN, MEX) => Uniform(1, 2),
         ROW => Normal(10, 3)]
```

which is equivalent to:

```
  foo[USA] = Uniform(0, 1),
  foo[(CAN, MEX)] = Uniform(1, 2),
  foo[ROW] = Normal(10, 3)]
```

To assign to parameters with more than one dimension, use square brackets around the dimensions
on the left-hand side of each `=>` operator, e.g.,

```
  bar = [[2050, USA] => Uniform(0, 1),
         [:, (CAN, MEX)] => Uniform(1, 2),
         [2010:10:2080, ROW] => Normal(10, 3)]
```

Currently, the more condensed syntax (using the pair operator `=>`) supports only direct assignment 
of RV value, i.e., you cannot combine this with the `*=` or `+=` operators.

## The set_models! function

The `run_sim` function assumes the `Simulation` instance has references to the model or models to run. The `set_models!` function has several methods for associating the model(s) to run with the `Simulation` instance:
	
```
set_models!(sim::Simulation, models::Vector{Model})
set_models!(sim::Simulation, m::Model)
set_models!(sim::Simulation, mm::MarginalModel)
```
	
## The run_sim function

In it's simplest use, the `run_sim` function iterates over all pre-generated trial data, perturbing a chosen subset of Mimi's "external parameters", based on the defined distributions, and then runs the given Mimi model. Optionally, trial values and/or model results are saved to CSV files.

### Function signature

The full signature for the `run_sim` is:

```
function run_sim(sim::Simulation; 
                 trials::Union{Nothing, Int, Vector{Int}, AbstractRange{Int}}=nothing,
                 models_to_run::Int=length(sim.models),
                 ntimesteps::Int=typemax(Int), 
                 output_dir::Union{Nothing, AbstractString}=nothing, 
                 pre_trial_func::Union{Nothing, Function}=nothing, 
                 post_trial_func::Union{Nothing, Function}=nothing,
                 scenario_func::Union{Nothing, Function}=nothing,
                 scenario_placement::ScenarioLoopPlacement=OUTER,
                 scenario_args=nothing)
```

The `run_sim` function runs the optionally indicated trial numbers, or by default trials, where the first `models_to_run` 
associated models are each run for `ntimesteps`, if specified, else to the maximum defined time period. 
Note that trial data are applied to all the associated models even when running only a portion of them.
    
If `pre_trial_func` or `post_trial_func` are defined, the designated functions are called 
just before or after (respectively) running a trial. The functions must have the signature:

    fn(sim::Simulation, trialnum::Int, ntimesteps::Int, tup::Tuple)

where `tup` is a tuple of scenario arguments representing one element in the cross-product
of all scenario value vectors. In situations in which you want the SA loop to run only
some of the models, the remainder of the runs can be handled using a `pre_trial_func` or
`post_trial_func`.

If provided, `scenario_args` must be a `Vector{Pair}`, where each `Pair` is a symbol and a 
`Vector` of arbitrary values that will be meaningful to `scenario_func`, which must have
the signature:

    scenario_func(sim::Simulation, tup::Tuple)

By default, the scenario loop encloses the SA loop, but the scenario loop can be
placed inside the SA loop by specifying `scenario_placement=INNER`. When `INNER` 
is specified, the `scenario_func` is called after any `pre_trial_func` but before the model
is run.

### Non-stochastic Scenarios

In many cases, scenarios (which we define as a choice of values from a discrete set for one or more parameters) need to be considered in addition to the stochastic parameter variation. To support scenarios, `run_sim` also offers iteration over discrete scenario values, which are passed to `run_sim` via the keyword parameter `scenario_args::Dict{Symbol, Vector}`. For example, to iterate over scenario values "a", and "b", as well as, say, discount rates `0.025, 0.05, 0.07`, you could provide the argument:

`scenario_args=Dict([:name => ["a", "b"], :rate => [0.025, 0.05, 0.07]])`

Of course, the SA subsystem does not know what you want to do with these values, so the user must also provide a callback function in the `scenario_func` argument. This function must be defined with the signature:

`function any_name_you_like(sim::Simulation, tup)`

where `tup` is an element of the set of tuples produced by calling `Itertools.product()` on all the scenario arguments. In the example above, this would produce the following vector of tuples:

`[("a", 0.025), ("b", 0.025), ("a", 0.03), ("b", 0.03), ("a", 0.05), ("b", 0.05)]`.

This approach allows all scenario combinations to be iterated over using a single loop. A final keyword argument, `scenario_placement::ScenarioLoopPlacement` indicates whether the scenario loop should occur inside or outside the loop over stochastic trial values. The type `ScenarioLoopPlacement` is an `enum` with values `INNER` and `OUTER`, the latter being the default placement.

In approximate pseudo-julia, these options produce the following behavior:

*scenario_placement=OUTER*
```julia
for tup in scenario_tuples
  scenario_func(tup)

  # for each scenario, run all SA trials
  for trial in trials
    trial_data = get_trial_data(trial)
    apply_trial_data()

    pre_trial_func()
    run(model)
    post_trial_func()
  end
end
```

*scenario_placement=INNER*
```julia
for trial in trials
  trial_data = get_trial_data(trial)
  apply_trial_data()

  # for each SA trial, run all scenarios
  for tup in scenario_tuples
    scenario_func(tup)

    pre_trial_func()
    run(model)
    post_trial_func()
  end
end
```

### Running Multiple Models

In some simulations, a baseline model needs to be compared to one or more models that are perturbed parametrically or structurally (i.e., with different components or equations.) To support this, the `Simulation` type holds a vector of `Model` instances, and allows the caller to specify how many of these to run automatically for each trial. Note that regardless of how many models are run, the random variables are applied to all of the models associated with the simulation.

By default, all defined models are run. In some cases, you may want to run some of the models "manually" in the `pre_trial_func` or `post_trial_func`, which allow you to make arbitrary modifications to these additional models.

**Example**

The following example is available in `"Mimi.jl/test/mcs/test_defsim.jl"`.

```julia
using Mimi
using Distributions

N = 100

sim = @defsim begin
    # Define random variables. The rv() is required to disambiguate an
    # RV definition name = Dist(args...) from application of a distribution
    # to an external parameter. This makes the (less common) naming of an
    # RV slightly more burdensome, but it's only required when defining
    # correlations or sharing an RV across parameters.
    rv(name1) = Normal(1, 0.2)
    rv(name2) = Uniform(0.75, 1.25)
    rv(name3) = LogNormal(20, 4)

    # assign RVs to model Parameters
    share = Uniform(0.2, 0.8)
    sigma[:, Region1] *= name2
    sigma[2020:5:2050, (Region2, Region3)] *= Uniform(0.8, 1.2)

    depk = [Region1 => Uniform(0.08, 0.14),
            Region2 => Uniform(0.10, 1.50),
            Region3 => Uniform(0.10, 0.20)]

    sampling(LHSData, corrlist=[(:name1, :name2, 0.7), (:name1, :name3, 0.5)])
    
    # indicate which parameters to save for each model run. Specify
    # a parameter name or [later] some slice of its data, similar to the
    # assignment of RVs, above.
    save(grosseconomy.K, grosseconomy.YGROSS, emissions.E, emissions.E_Global)
end

Mimi.reset_compdefs()
include("../../examples/tutorial/02-two-region-model/main.jl")

m = model

# Optionally, user functions can be called just before or after a trial is run
function print_result(m::Model, sim::Simulation, trialnum::Int)
    ci = Mimi.compinstance(m.mi, :emissions)
    value = Mimi.get_variable_value(ci, :E_Global)
    println("$(ci.comp_id).E_Global: $value")
end

output_dir = joinpath(tempdir(), "sim")

generate_trials!(sim, N, filename=joinpath(output_dir, "trialdata.csv"))

# Run trials 1:N, and save results to the indicated directory
set_models!(sim, m)
run_sim(sim, output_dir=output_dir)
```
